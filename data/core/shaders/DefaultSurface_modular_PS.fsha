FSHA_10_0037_0041_067D_06C8_7CBB_04_0000838D_00003F20
########
{
  "ShaderStage": 16,
  "RequiredVariants": 15,
  "SourceCode": {
    "EntryPointNameBase": "Main_Pixel",
    "EntryPoints": [
      {
        "VariantFlags": 1,
        "EntryPoint": "Main_Pixel"
      },
      {
        "VariantFlags": 3,
        "EntryPoint": "Main_Pixel_Ext"
      },
      {
        "VariantFlags": 1,
        "EntryPoint": "Main_Pixel"
      },
      {
        "VariantFlags": 3,
        "EntryPoint": "Main_Pixel_Ext"
      }
    ],
    "SupportedFeaturesTxt": "At_Nyy_Ly111p185_V110",
    "MaximumCompiledFeaturesTxt": "At_Nyn_Ly101p140_V110",
    "SourceCodeBlocks": [
      {
        "Language": 1,
        "ByteOffset": 0,
        "ByteSize": 23573
      },
      {
        "Language": 2,
        "ByteOffset": 23573,
        "ByteSize": 8338
      }
    ]
  },
  "CompiledVariants": [
    {
      "Type": 1,
      "VariantFlags": 1,
      "VariantDescriptionTxt": "At_Nyn_Ly101p0_V100",
      "EntryPoint": "Main_Pixel",
      "ByteOffset": 0,
      "ByteSize": 7860
    },
    {
      "Type": 1,
      "VariantFlags": 3,
      "VariantDescriptionTxt": "At_Nyn_Ly101p0_V100",
      "EntryPoint": "Main_Pixel_Ext",
      "ByteOffset": 7860,
      "ByteSize": 8300
    },
    {
      "Type": 4,
      "VariantFlags": 1,
      "VariantDescriptionTxt": "At_Nyn_Ly101p0_V100",
      "EntryPoint": "Main_Pixel",
      "ByteOffset": 0,
      "ByteSize": 7860
    },
    {
      "Type": 4,
      "VariantFlags": 3,
      "VariantDescriptionTxt": "At_Nyn_Ly101p0_V100",
      "EntryPoint": "Main_Pixel_Ext",
      "ByteOffset": 7860,
      "ByteSize": 8300
    }
  ]
}########
//#pragma pack_matrix( column_major )

/******************* DEFINES: ******************/

// Albedo:
#define FEATURE_ALBEDO_TEXTURE 1                // Whether to initialize albedo color from main texture. If false, a color literal is used
#define FEATURE_ALBEDO_COLOR half4(1, 1, 1, 1)  // Color literal from which albedo may be initialized

// Normals:
#define FEATURE_NORMALS                         // Whether to use normal maps in all further shading
#define FEATURE_PARALLAX                        // Whether to use height/parallax maps to modulate UV sampling
#define FEATURE_PARALLAX_FULL                   // Whether to use full iteratively traced parallax with occlusion, instead of just simple UV offsetting.

// Lighting:
#define FEATURE_LIGHT                           // Whether to apply lighting
#define FEATURE_LIGHT_AMBIENT                   // Whether to add directional ambient intensity to base lighting
#define FEATURE_LIGHT_LIGHTMAPS                 // Whether to add light map intensity to base lighting
#define FEATURE_LIGHT_SOURCES                   // Whether to use light sources from the scene to light up the object
#define FEATURE_LIGHT_MODEL Phong
#define FEATURE_LIGHT_SHADOWMAPS                // Whether to use shadow maps to mask out light rays coming from light sources
#define FEATURE_LIGHT_SHADOWMAPS_RES 1024       // The resolution of shadow maps, in pixels per side.
#define FEATURE_LIGHT_SHADOWMAPS_AA 2           // If defined, controls the number of depth samples read from shadow map per pixel 
#define FEATURE_LIGHT_INDIRECT 5                // If defined, controls the number of indirect light samples per pixel, sample count is NxN, must be 2 or higher

// Variants:
#define VARIANT_EXTENDED                        // Whether to always create a shader variant using extended surface data
#define VARIANT_BLENDSHAPES                     // Whether to always create a shader variant using blend shape data
#define VARIANT_ANIMATED                        // Whether to always create a shader variant using bone animation data

#if FEATURE_ALBEDO_TEXTURE == 0
    #ifndef FEATURE_ALBEDO_COLOR
        #define FEATURE_ALBEDO_COLOR half4(1, 1, 1, 1)
    #endif
#endif

/****************** CONSTANTS: *****************/

#ifdef FEATURE_LIGHT_AMBIENT
// Constant buffer containing all scene-wide settings:
cbuffer CBScene : register(b0)
{
    // Scene lighting:
    float4 ambientLightLow;         // Ambient light color and intensity coming from bottom-up.
    float4 ambientLightMid;         // Ambient light color and intensity coming from all sides.
    float4 ambientLightHigh;        // Ambient light color and intensity coming from top-down.
    float shadowFadeStart;          // Percentage of the shadow distance in projection space where they start fading out.
};
#endif //FEATURE_LIGHT_AMBIENT

#if defined(FEATURE_LIGHT_SOURCES) || defined(FEATURE_PARALLAX)
// Constant buffer containing all settings that apply for everything drawn by currently active camera:
cbuffer CBCamera : register(b1)
{
    // Camera vectors & matrices:
    float4x4 mtxWorld2Clip;         // Camera's full projection matrix, transforming from world space to clip space coordinates.
    float4 cameraPosition;          // Camera position, in world space.
    float4 cameraDirection;         // Camera forward facing direction, in world space.
    float4x4 mtxCameraMotion;       // Camera movement matrix, encoding motion/transformation from previous to current frame.

	// Camera parameters:
    uint cameraIdx;                 // Index of the currently drawing camera.
    uint resolutionX;               // Render target width, in pixels.
    uint resolutionY;               // Render target height, in pixels.
    float nearClipPlane;            // Camera's near clipping plane distance.
    float farClipPlane;             // Camera's far clipping plane distance.

    // Per-camera lighting:
    uint lightCount;                // Total number of lights affecting this camera.
    uint shadowMappedLightCount;    // Total number of lights that have a layer of the shadow map texture array assigned.
};
#endif //FEATURE_LIGHT_SOURCES

// Constant buffer containing only object-specific settings:
cbuffer CBObject : register(b2)
{
    float4x4 mtxLocal2World;        // Object world matrix, transforming vertices from model space to world space.
    float3 worldPosition;           // World space position of the object.
    float boundingRadius;           // Bounding sphere radius of the object.
};

// Constant buffer containing material-specific settings:
cbuffer CBDefaultSurface : register(b3)
{
    float4 tintColor;               // Color tint applied to albedo.
    float roughness;                // Roughness rating of the surface.
    float shininess;                // How shiny or metallic the surface is.
    float reflectionIndex;          // Reflection index of the material's surface.
    float refractionIndex;          // Refraction index of the material's substance.
};

/****************** RESOURCES: *****************/

// ResSetCamera:

#ifdef FEATURE_LIGHT_SOURCES
struct Light
{
    float3 lightColor;
    float lightIntensity;
    float3 lightPosition;
    uint lightType;
    float3 lightDirection;
    float lightSpotMinDot;
    uint shadowMapIdx;
    float shadowBias;
    uint shadowCascades;
    float shadowCascadeRange;
    float3 shadowDepthBias;
    float _padding;
};

StructuredBuffer<Light> BufLights : register(ps, t0);               // Buffer containing an array of light source data. Number of lights is given in 'CBGlobal.lightCount'.
#endif

#ifdef FEATURE_LIGHT_SHADOWMAPS
Texture2DArray<half> TexShadowMaps : register(ps, t1);
StructuredBuffer<float4x4> BufShadowMatrices : register(ps, t3);    // Buffer containing an array of projection matrices for shadow maps, transforming world position to clip space and back.
SamplerState SamplerShadowMaps : register(ps, s0);
    #if defined(FEATURE_LIGHT_INDIRECT) && FEATURE_LIGHT_INDIRECT > 1
    Texture2DArray<half3> TexShadowNormalMaps : register(ps, t2);
    #endif
#endif

// ResSetBound:

#if FEATURE_ALBEDO_TEXTURE == 1
Texture2D<half4> TexMain : register(ps, t4);
#endif //FEATURE_ALBEDO_TEXTURE == 1

#ifdef FEATURE_NORMALS
Texture2D<half3> TexNormal : register(ps, t5);
#endif //FEATURE_NORMALS

#ifdef FEATURE_PARALLAX
Texture2D<half> TexParallax : register(ps, t6);
#endif //FEATURE_PARALLAX

#ifdef FEATURE_LIGHT_LIGHTMAPS
Texture2D<half3> TexLightmap : register(ps, t7);
#endif //FEATURE_LIGHT_LIGHTMAPS

#if FEATURE_ALBEDO_TEXTURE == 1 || defined(FEATURE_NORMALS) || defined(FEATURE_PARALLAX) || defined(FEATURE_LIGHT_LIGHTMAPS)
    #define HAS_SAMPLER_MAIN
    SamplerState SamplerMain : register(s1);
#endif //HAS_SAMPLER_MAIN


/**************** VERTEX OUTPUT: ***************/

struct VertexOutput_Basic
{
    float4 position : SV_POSITION;
    float3 worldPosition : COLOR0;
    float3 normal : NORMAL0;
    float2 uv : TEXCOORD0;
};

#ifdef VARIANT_EXTENDED
struct VertexOutput_Extended
{
    float3 tangent : TANGENT0;
    float3 binormal : NORMAL1;
    float2 uv2 : TEXCOORD1;
};
#endif //VARIANT_EXTENDED

#ifdef FEATURE_LIGHT

/****************** LIGHTING: ******************/

#ifdef FEATURE_LIGHT_AMBIENT
half3 CalculateAmbientLight(const in float3 _worldNormal)
{
    const half dotY = (half)dot(_worldNormal, float3(0, 1, 0));
    const half wLow = max(-dotY, 0);
    const half wHigh = max(dotY, 0);
    const half wMid = 1.0 - wHigh - wLow;
    return (wLow * (half4)ambientLightLow + wHigh * (half4)ambientLightHigh + wMid * (half4)ambientLightMid).xyz;
}
#endif //FEATURE_LIGHT_AMBIENT

#ifdef FEATURE_LIGHT_LIGHTMAP
half3 CalculateLightmaps(const in float2 _uv)
{
    return TexLightmap.Sample(SamplerMain, _uv);
}
#endif //FEATURE_LIGHT_LIGHTMAP

#ifdef FEATURE_LIGHT_SOURCES
#if FEATURE_LIGHT_MODEL == Phong
half3 CalculatePhongLighting(const in Light _light, const in float3 _worldPosition, const in float3 _worldNormal)
{
    half3 lightIntens = (half3)(_light.lightColor * _light.lightIntensity);
    float3 lightRayDir;

    // Directional light:
    if (_light.lightType == 2)
    {
        lightRayDir = _light.lightDirection;
    }
    // Point or Spot light:
    else
    {
        const float3 lightOffset = _worldPosition - _light.lightPosition;
        lightIntens /= (half)dot(lightOffset, lightOffset);
        lightRayDir = normalize(lightOffset);

        // Spot light angle:
        if (_light.lightType == 1 && dot(_light.lightDirection, lightRayDir) < _light.lightSpotMinDot)
        {
            lightIntens = half3(0, 0, 0);
        }
    }

    const half lightDot = max(-(half)dot(lightRayDir, _worldNormal), 0.0);
    return lightIntens.xyz * lightDot;
}
//... (insert further lighting models here)
#endif //FEATURE_LIGHT_MODEL == Phong

#ifdef FEATURE_LIGHT_SHADOWMAPS
#if defined(FEATURE_LIGHT_INDIRECT) && FEATURE_LIGHT_INDIRECT > 1
half3 CalculateIndirectLightScatter(const in Light _light, const in float3 _worldPosition, const in float3 _surfaceNormal)
{
    static const int halfKernel = FEATURE_LIGHT_INDIRECT / 2;
    static const half uvKernelSteps = 1.0 / 256;
    static const float bounceAmount = 0.025;

    // Determine shadow cascade for this pixel:
    const float cameraDist = length(_worldPosition - cameraPosition.xyz);
    const uint cascadeOffset = (uint)(2 * cameraDist / _light.shadowCascadeRange);
    const uint cascadeIdx = min(cascadeOffset, _light.shadowCascades);
    const uint shadowMapIdx = _light.shadowMapIdx + cascadeIdx;

    const float4x4 mtxShadowWorld2Clip = BufShadowMatrices[2 * shadowMapIdx];
    const float4x4 mtxShadowClip2World = BufShadowMatrices[2 * shadowMapIdx + 1];

    // Add a bias to position along surface normal, to counter-act stair-stepping artifacts:
    const float4 worldPosBiased = float4(_worldPosition + _surfaceNormal * _light.shadowBias, 1);

    // Transform pixel position to light's clip space, then to UV space:
    float4 shadowProj = mul(mtxShadowWorld2Clip, worldPosBiased);
    shadowProj /= shadowProj.w;
    const float2 shadowUv = float2(shadowProj.x + 1, 1 - shadowProj.y) * 0.5;

    float lightBounceSum = 0.0;

    for (int y = -halfKernel; y < halfKernel; ++y)
    {
        const half uvY = shadowUv.y + y * uvKernelSteps;
        for (int x = -halfKernel; x < halfKernel; ++x)
        {
            const half uvX = shadowUv.x + x * uvKernelSteps;
            const half3 uv = half3(uvX, uvY, _light.shadowMapIdx);

            const half3 normal = TexShadowNormalMaps.Sample(SamplerShadowMaps, uv) * 2 - 1;
            const half depth = TexShadowMaps.Sample(SamplerShadowMaps, uv);

            const half4 posClipSpace = half4(uvX * 2 - 1, 1 - uvY * 2, depth, 1);
            const float3 posWorld = mul(mtxShadowClip2World, posClipSpace).xyz;

            // Determine approximate lighting at sampled point, pre-bounce:
            const float3 lightOffset = posWorld - _light.lightPosition;
            const float intensityPreBounce = max(-dot(lightOffset / length(lightOffset), normal), 0) / dot(lightOffset, lightOffset);

            // Determine radiated lighting at center point, post-bounce:
            const float3 offsetBounced = worldPosBiased.xyz - posWorld;
            const float distSqBounced = dot(offsetBounced, offsetBounced);
            const float intensityPostBounce = intensityPreBounce / distSqBounced;

            lightBounceSum += dot(offsetBounced, _surfaceNormal) < 0 ? intensityPostBounce : 0;
        }
    }
    lightBounceSum *= bounceAmount;

    return lightBounceSum * _light.lightIntensity * _light.lightColor;
}

#endif //FEATURE_LIGHT_INDIRECT
#define SHADOW_EDGE_FACE_SCALE 10.0

#if defined(FEATURE_LIGHT_SHADOWMAPS_AA) && FEATURE_LIGHT_SHADOWMAPS_AA > 1
    // MSAA offsets for shadow depth sampling:
    #if FEATURE_LIGHT_SHADOWMAPS_AA == 2
        static const float2 shadowSamplingOffsets[] =
        {
            { -0.5 / FEATURE_LIGHT_SHADOWMAPS_RES, -0.25 / FEATURE_LIGHT_SHADOWMAPS_RES },
            {  0.5 / FEATURE_LIGHT_SHADOWMAPS_RES,  0.25 / FEATURE_LIGHT_SHADOWMAPS_RES }
        };
    #elif FEATURE_LIGHT_SHADOWMAPS_AA == 4
        static const float2 shadowSamplingOffsets[] =
        {
            {  0, 0 },
            {  0, 0.5 / FEATURE_LIGHT_SHADOWMAPS_RES },
            { -0.25 / FEATURE_LIGHT_SHADOWMAPS_RES, -0.25 / FEATURE_LIGHT_SHADOWMAPS_RES },
            {  0.25 / FEATURE_LIGHT_SHADOWMAPS_RES, -0.25 / FEATURE_LIGHT_SHADOWMAPS_RES },
        };
    #elif FEATURE_LIGHT_SHADOWMAPS_AA == 8
        static const float2 shadowSamplingOffsets[] =
        {
            {  0, 0 },
            {  0,  0.5 / FEATURE_LIGHT_SHADOWMAPS_RES },
            {  0, -0.5 / FEATURE_LIGHT_SHADOWMAPS_RES },
            {  0.5 / FEATURE_LIGHT_SHADOWMAPS_RES, 0 },
            { -0.5 / FEATURE_LIGHT_SHADOWMAPS_RES, 0 },
            { -0.25 / FEATURE_LIGHT_SHADOWMAPS_RES, 0.2 / FEATURE_LIGHT_SHADOWMAPS_RES },
            { -0.25 / FEATURE_LIGHT_SHADOWMAPS_RES, -0.2 / FEATURE_LIGHT_SHADOWMAPS_RES },
            {  0.25 / FEATURE_LIGHT_SHADOWMAPS_RES, 0.2 / FEATURE_LIGHT_SHADOWMAPS_RES },
            {  0.25 / FEATURE_LIGHT_SHADOWMAPS_RES, -0.2 / FEATURE_LIGHT_SHADOWMAPS_RES },
        };
    #else
        #error "Shadow sampling count FEATURE_LIGHT_SHADOWMAPS_AA can only be 2 or 4"
    #endif
#endif

half CalculateShadowMapLightWeight(const in Light _light, const in float3 _worldPosition, const in float3 _surfaceNormal)
{
    // Determine shadow cascade for this pixel:
    const float cameraDist = length(_worldPosition - cameraPosition.xyz);
    const uint cascadeOffset = (uint)(2 * cameraDist / _light.shadowCascadeRange);
    const uint cascadeIdx = min(cascadeOffset, _light.shadowCascades);
    const uint shadowMapIdx = _light.shadowMapIdx + cascadeIdx;

    // Add a bias to position along surface normal, to counter-act stair-stepping artifacts:
    const float4 worldPosBiased = float4(_worldPosition + _surfaceNormal * _light.shadowBias + _light.shadowDepthBias, 1);

    // Transform pixel position to light's clip space, then to UV space:
    float4 shadowProj = mul(BufShadowMatrices[2 * shadowMapIdx], worldPosBiased);
    shadowProj /= shadowProj.w;
    const float2 shadowUv = float2(shadowProj.x + 1, 1 - shadowProj.y) * 0.5;

#if defined(FEATURE_LIGHT_SHADOWMAPS_AA) && FEATURE_LIGHT_SHADOWMAPS_AA > 1
    // Calculate shadow depth by averaging from multiple samples:
    static const half invShadowSampleCount = 1.0 / FEATURE_LIGHT_SHADOWMAPS_AA;
    half lightWeight = 0;
    for (uint i = 0; i < FEATURE_LIGHT_SHADOWMAPS_AA; ++i)
    {
        const float2 shadowSampleUv = shadowUv + shadowSamplingOffsets[i];
        const half shadowDepth = TexShadowMaps.Sample(SamplerShadowMaps, float3(shadowSampleUv.x, shadowSampleUv.y, shadowMapIdx));
        lightWeight += shadowDepth > shadowProj.z ? 1 : 0;
    }
    lightWeight *= invShadowSampleCount;
#else
    // Calculate shadow depth from a single sample:
    const half shadowDepth = TexShadowMaps.Sample(SamplerShadowMaps, float3(shadowUv.x, shadowUv.y, shadowMapIdx));
    half lightWeight = shadowDepth > shadowProj.z ? 1 : 0;
#endif //FEATURE_LIGHT_SHADOWMAPS_AA
    
    // Fade shadows out near boundaries of UV/Depth space:
    if (_light.lightType == 2 && shadowMapIdx == _light.shadowCascades)
    {
        const half3 edgeUv = half3(shadowUv, shadowProj.z) * SHADOW_EDGE_FACE_SCALE;
        const half3 edgeMax = min(min(edgeUv, SHADOW_EDGE_FACE_SCALE - edgeUv), 1);
        const half k = 1 - min(min(edgeMax.x, edgeMax.y), edgeMax.z);
        lightWeight = lerp(lightWeight, 1.0, clamp(k, 0, 1));
    }

    return lightWeight;
}
#endif //FEATURE_LIGHT_SHADOWMAPS
#endif //FEATURE_LIGHT_SOURCES

half3 CalculateTotalLightIntensity(const in float3 _worldPosition, const in float3 _worldNormal, const in float3 _surfaceNormal, const in float2 _uv)
{
    #ifdef FEATURE_LIGHT_AMBIENT
    half3 totalLightIntensity = CalculateAmbientLight(_worldNormal);
    #else
    half3 totalLightIntensity = half3(0, 0, 0);
    #endif //FEATURE_LIGHT_AMBIENT

    // Apply light maps:
    #ifdef FEATURE_LIGHT_LIGHTMAP
    totalLightIntensity += CalculateLightmaps(_uv);
    #endif

    #ifdef FEATURE_LIGHT_SOURCES
    {
        uint i = 0;
        #ifdef FEATURE_LIGHT_SHADOWMAPS
        // Shadow-casting light sources:
        for (; i < shadowMappedLightCount; ++i)
        {
            Light light = BufLights[i];

            const half3 lightIntensity = CalculatePhongLighting(light, _worldPosition, _worldNormal);
            const half lightWeight = CalculateShadowMapLightWeight(light, _worldPosition, _surfaceNormal);
            totalLightIntensity += lightIntensity * lightWeight;

            #ifdef FEATURE_LIGHT_INDIRECT
            totalLightIntensity += CalculateIndirectLightScatter(light, _worldPosition, _surfaceNormal);
            #endif //FEATURE_LIGHT_INDIRECT
        }
        #else
        uint shadowMappedLightCount = 0;
        #endif //FEATURE_LIGHT_SHADOWMAPS
        // Simple light sources:
        for (i = shadowMappedLightCount; i < lightCount; ++i)
        {
            totalLightIntensity += CalculatePhongLighting(BufLights[i], _worldPosition, _worldNormal);
        }
    }
    #endif //FEATURE_LIGHT_SOURCES

    return totalLightIntensity;
}

#endif //FEATURE_LIGHT

#ifdef FEATURE_NORMALS
/******************* NORMALS: ******************/

half3 UnpackNormalMap(const in half3 _texNormal)
{
    // Unpack direction vector from normal map colors:
    return half3(_texNormal.x * 2 - 1, _texNormal.z, _texNormal.y * 2 - 1); // NOTE: Texture normals are expected to be in OpenGL standard.
}

half3 ApplyNormalMap(const in half3 _worldNormal, const in half3 _worldTangent, const in half3 _worldBinormal, in half3 _texNormal)
{
    _texNormal = UnpackNormalMap(_texNormal);

    // Create rotation matrix, projecting from flat surface (UV) space to surface in world space:
    const half3x3 mtxNormalRot =
    {
        _worldBinormal.x, _worldNormal.x, _worldTangent.x,
        _worldBinormal.y, _worldNormal.y, _worldTangent.y,
        _worldBinormal.z, _worldNormal.z, _worldTangent.z,
    };
    const half3 normal = mul(mtxNormalRot, _texNormal);
    return normal;
}
#endif //FEATURE_NORMALS

#ifdef FEATURE_PARALLAX
/****************** PARALLAX: ******************/

float3 ProjectOnPlane(const float3 _vector, const float3 _planeNormal)
{
    return _vector - dot(_vector, _planeNormal);
}

half2 WorldOffset2Pixel(
    const float3 _worldOffset,
    const in float3 _worldPosition,
    const in half2 _uv)
{
    const float3 ddxPos = ddx(_worldPosition);
    const float3 ddyPos = ddy(_worldPosition);
    const float invWorldPerPixelX = 1.0 / length(ddxPos);
    const float invWorldPerPixelY = 1.0 / length(ddyPos);
    return
        ddx(_uv) * (half)dot(_worldOffset, ddxPos * invWorldPerPixelX) +
        ddy(_uv) * (half)dot(_worldOffset, ddyPos * invWorldPerPixelY);
}

half2 ApplyParallaxMap(const in float3 _worldPosition, const in float3 _surfaceNormal, const half2 _uv)
{
    static const float MAX_DEPTH = 0.05;

    const float3 viewOffset = _worldPosition - cameraPosition.xyz;
    
#ifdef FEATURE_PARALLAX_FULL
    static const uint MAX_ITERATIONS = 6;

    const float invViewDist = 1.0 / length(viewOffset);
    const float3 viewDir = viewOffset * invViewDist;

    const float3 maxRayOffset = viewDir * abs(MAX_DEPTH / dot(viewDir, _surfaceNormal));
    const float3 maxSurfaceOffset = ProjectOnPlane(maxRayOffset, _surfaceNormal);
    const half2 maxUvOffset = WorldOffset2Pixel(maxSurfaceOffset, _worldPosition, _uv) * 200 * invViewDist;

    half2 uvOffset;
    half2 curUV = _uv;
    float minK = 0.0;
    float maxK = 1.0;

    for (uint i = 0; i < MAX_ITERATIONS; ++i)
    {
        float k = 0.5 * (minK + maxK);
        
        const float3 rayOffset = k * maxRayOffset;
        uvOffset = k * maxUvOffset;
        curUV = _uv + uvOffset;

        const half sampledHeight = (1.0 - TexParallax.Sample(SamplerMain, curUV)) * MAX_DEPTH;
        const half rayHeight = abs(dot(rayOffset, _surfaceNormal));

        if (sampledHeight > rayHeight)
        {
            minK = k;
        }
        else
        {
            maxK = k;
        }
    }
    return curUV + normalize(uvOffset) * 0.002;
#else
    const float3 surfaceDir = normalize(ProjectOnPlane(viewOffset, _surfaceNormal));
    
    const half depth = TexParallax.Sample(SamplerMain, _uv) * MAX_DEPTH;

    return _uv - WorldOffset2Pixel(surfaceDir * depth, _worldPosition, _uv) * 100;
#endif //FEATURE_PARALLAX_FULL
}
#endif //FEATURE_PARALLAX

/******************* SHADERS: ******************/

half4 Main_Pixel(in VertexOutput_Basic inputBasic) : SV_Target0
{
    #ifdef FEATURE_PARALLAX
    // Recalculate UV from parallax map:
    float2 uv = ApplyParallaxMap(inputBasic.worldPosition, inputBasic.normal, inputBasic.uv);
    #else
    float2 uv = inputBasic.uv;
    #endif //FEATURE_PARALLAX

    #if FEATURE_ALBEDO_TEXTURE == 1
    // Sample base color from main texture:
    half4 albedo = TexMain.Sample(SamplerMain, uv);
    #else
    half4 albedo = FEATURE_ALBEDO_COLOR;
    #endif //FEATURE_ALBEDO_TEXTURE == 1

    #ifdef FEATURE_NORMALS
    // Calculate normals from normal map:
    half3 normal = TexNormal.Sample(SamplerMain, uv);
    normal = ApplyNormalMap(inputBasic.normal, half3(0, 0, 1), half3(1, 0, 0), normal);
    #else
    half3 normal = inputBasic.normal;
    #endif //FEATURE_NORMALS

    #ifdef FEATURE_LIGHT
    // Apply basic phong lighting:
    const half3 totalLightIntensity = CalculateTotalLightIntensity(inputBasic.worldPosition, normal, inputBasic.normal, uv);

    albedo *= half4(totalLightIntensity, 1);
    #endif //FEATURE_LIGHT

    // Return final color:
    return albedo;
};

#ifdef VARIANT_EXTENDED
half4 Main_Pixel_Ext(in VertexOutput_Basic inputBasic, in VertexOutput_Extended inputExt) : SV_Target0
{
    #ifdef FEATURE_PARALLAX
    // Recalculate UV from parallax map:
    float2 uv = ApplyParallaxMap(inputBasic.worldPosition, inputBasic.normal, inputBasic.uv);
    #else
    float2 uv = inputBasic.uv;
    #endif //FEATURE_PARALLAX

    #if FEATURE_ALBEDO_TEXTURE == 1
    // Sample base color from main texture:
    half4 albedo = TexMain.Sample(SamplerMain, uv);
    #else
    half4 albedo = FEATURE_ALBEDO_COLOR;
    #endif //FEATURE_ALBEDO_TEXTURE == 1

    #ifdef FEATURE_NORMALS
    // Calculate normals from normal map:
    half3 normal = TexNormal.Sample(SamplerMain, uv);
    normal = ApplyNormalMap(inputBasic.normal, inputExt.tangent, inputExt.binormal, normal);
    #else
    half3 normal = inputBasic.normal;
    #endif //FEATURE_NORMALS

    #ifdef FEATURE_LIGHT
    // Apply basic phong lighting:
    const half3 totalLightIntensity = CalculateTotalLightIntensity(inputBasic.worldPosition, normal, inputBasic.normal, uv);

    albedo *= half4(totalLightIntensity, 1);
    #endif //FEATURE_LIGHT

    // Return final color:
    return albedo;
};
#endif //VARIANT_EXTENDED
########
#include <metal_stdlib>
using namespace metal;

/******************* DEFINES: ******************/

// Albedo:
#define FEATURE_ALBEDO_TEXTURE 1                // Whether to initialize albedo color from main texture. If false, a color literal is used
#define FEATURE_ALBEDO_COLOR half4(1, 1, 1, 1)  // Color literal from which albedo may be initialized

// Normals:
#define FEATURE_NORMALS                         // Whether to use normal maps in all further shading

// Lighting:
#define FEATURE_LIGHT                           // Whether to apply lighting
#define FEATURE_LIGHT_AMBIENT                   // Whether to add directional ambient intensity to base lighting
#define FEATURE_LIGHT_LIGHTMAPS                 // Whether to add light map intensity to base lighting
#define FEATURE_LIGHT_SOURCES                   // Whether to use light sources from the scene to light up the object
#define FEATURE_LIGHT_MODEL Phong               // Which lighting model to use for light sources. Default is "Phong"
#define FEATURE_LIGHT_SHADOWMAPS                // Whether to use shadow maps to mask out light rays coming from light sources

// Variants:
#define VARIANT_EXTENDED                        // Whether to always create a shader variant using extended surface data
#define VARIANT_BLENDSHAPES                     // Whether to always create a shader variant using blend shape data
#define VARIANT_ANIMATED                        // Whether to always create a shader variant using bone animation data    

#if FEATURE_ALBEDO_TEXTURE == 0
    #ifndef FEATURE_ALBEDO_COLOR
        #define FEATURE_ALBEDO_COLOR half4(1, 1, 1, 1)
    #endif
#endif

/****************** CONSTANTS: *****************/

#ifdef FEATURE_LIGHT_AMBIENT
// Constant buffer containing all scene-wide settings:
struct CBScene
{
    // Scene lighting:
    float4 ambientLightLow;         // Ambient light color and intensity coming from bottom-up.
    float4 ambientLightMid;         // Ambient light color and intensity coming from all sides.
    float4 ambientLightHigh;        // Ambient light color and intensity coming from top-down.
    float shadowFadeStart;          // Percentage of the shadow distance in projection space where they start fading out.
};
#endif //FEATURE_LIGHT_AMBIENT

#ifdef FEATURE_LIGHT_SOURCES
// Constant buffer containing all settings that apply for everything drawn by currently active camera:
struct CBCamera
{
    // Camera vectors & matrices:
    float4x4 mtxWorld2Clip;         // Camera's full projection matrix, transforming from world space to clip space coordinates.
    float4 cameraPosition;          // Camera position, in world space.
    float4 cameraDirection;         // Camera forward facing direction, in world space.
    float4x4 mtxCameraMotion;       // Camera movement matrix, encoding motion/transformation from previous to current frame.

	// Camera parameters:
    uint cameraIdx;                 // Index of the currently drawing camera.
    uint resolutionX;               // Render target width, in pixels.
    uint resolutionY;               // Render target height, in pixels.
    float nearClipPlane;            // Camera's near clipping plane distance.
    float farClipPlane;             // Camera's far clipping plane distance.

    // Per-camera lighting:
    uint lightCount;                // Total number of lights affecting this camera.
    uint shadowMappedLightCount;    // Total number of lights that have a layer of the shadow map texture array assigned.
};
#endif //FEATURE_LIGHT_SOURCES

struct CBObject
{
    float4x4 mtxLocal2World;    // Object world matrix, transforming vertices from model space to world space.
    float3 worldPosition;       // World space position of the object.
    float boundingRadius;       // Bounding sphere radius of the object.
};

/****************** RESOURCES: *****************/

#ifdef FEATURE_LIGHT_SOURCES
struct Light
{
    float3 lightColor;
    float lightIntensity;
    float3 lightPosition;
    uint lightType;
    float3 lightDirection;
    float lightSpotMinDot;
    float4x4 mtxShadowWorld2Clip;
    uint shadowMapIdx;
    float shadowBias;
    float shadowDepthBias;
    uint shadowCascades;
    float shadowCascadeRange;
};
#endif

/**************** VERTEX OUTPUT: ***************/

struct VertexOutput_Basic
{
    float4 position         [[ position ]];
    float3 worldPosition    [[ user(worldPosition) ]];
    float3 normal           [[ user(normal) ]];
    float2 uv               [[ user(uv) ]];
};

#ifdef VARIANT_EXTENDED
struct VertexOutput_Extended
{
    float4 position         [[ position ]];
    float3 worldPosition    [[ user(worldPosition) ]];
    float3 normal           [[ user(normal) ]];
    float2 uv               [[ user(uv) ]];

    float3 tangent          [[ user(tangent) ]];
    float3 binormal         [[ user(binormal) ]];
    float2 uv2              [[ user(uv2) ]];
};
#else
#endif //VARIANT_EXTENDED

#ifdef FEATURE_LIGHT
/****************** LIGHTING: ******************/

half3 CalculateAmbientLight(
    device const CBScene& cbScene,
    const float3& _normal)
{
    const half dotY = (half)dot(_normal, float3(0, 1, 0));
    const half wLow = max(-dotY, (half)0);
    const half wHigh = max(dotY, (half)0);
    const half wMid = 1 - wHigh - wLow;
    return (wLow * (half4)cbScene.ambientLightLow + wHigh * (half4)cbScene.ambientLightHigh + wMid * (half4)cbScene.ambientLightMid).xyz;
}

#else
#endif //FEATURE_LIGHT

#ifdef FEATURE_NORMALS
/******************* NORMALS: ******************/

half3 UnpackNormalMap(const half3& _texNormal)
{
    // Unpack direction vector from normal map colors:
    return half3(_texNormal.x * 2 - 1, _texNormal.z, _texNormal.y * 2 - 1); // NOTE: Texture normals are expected to be in OpenGL standard.
}

half3 ApplyNormalMap(const half3& _worldNormal, const half3& _worldTangent, const half3& _worldBinormal, half3 _texNormal)
{
    _texNormal = UnpackNormalMap(_texNormal);

    // Create rotation matrix, projecting from flat surface (UV) space to surface in world space:
    const half3x3 mtxNormalRot =
    {
        _worldBinormal.x, _worldNormal.x, _worldTangent.x,
        _worldBinormal.y, _worldNormal.y, _worldTangent.y,
        _worldBinormal.z, _worldNormal.z, _worldTangent.z,
    };
    const half3 normal = mtxNormalRot * _texNormal;
    return normal;
}
#else
#endif //FEATURE_NORMALS

/******************* SHADERS: ******************/

half4 fragment Main_Pixel(
    VertexOutput_Basic inputBasic                       [[ stage_in ]],
    device const CBScene& cbScene                       [[ buffer( 0 ) ]],
    device const CBCamera& cbCamera                     [[ buffer( 1 ) ]],
    device const CBObject& cbObject                     [[ buffer( 2 ) ]],
    device const Light* BufLights                       [[ buffer( 3 ) ]],
    texture2d_array<half, access::sample> TexShadowMaps [[ texture( 0 ) ]])
{
    half4 albedo = {1, 1, 1, 1};

    // Apply basic phong lighting:
    half3 totalLightIntensity = CalculateAmbientLight(cbScene, inputBasic.normal);
    for (uint i = 0; i < cbCamera.lightCount; ++i)
    {
        device const Light& light = BufLights[i];

        half3 lightIntens = (half3)(light.lightColor * light.lightIntensity);
        float3 lightRayDir;

        // Directional light:
        if (light.lightType == 2)
        {
            lightRayDir = light.lightDirection;
        }
        // Point or Spot light:
        else
        {
            const float3 lightOffset = inputBasic.worldPosition - light.lightPosition;
            lightIntens /= (half)dot(lightOffset, lightOffset);
            lightRayDir = normalize(lightOffset);

            // Spot light angle:
            if (light.lightType == 1 && dot(light.lightDirection, lightRayDir) < light.lightSpotMinDot)
            {
                lightIntens = half3(0, 0, 0);
            }
        }

        const half lightDot = max(-(half)dot(lightRayDir, inputBasic.normal), (half)0.0);
        totalLightIntensity += lightIntens.xyz * lightDot;
    }
    albedo *= half4(totalLightIntensity, 1);

    // Return final color:
    return albedo;
};
########
          DXBCrï¿½nCï¿½ï¿½,ï¿½?ï¿½qBï¿½1   ï¿½     8   H   ï¿½   8  L  h  SFI0           ISG1ï¿½             ï¿½                            ï¿½                           ï¿½                           ï¿½                       SV_Position COLOR NORMAL TEXCOORD   OSG14             (       @                 SV_Target   PSV0  4                       ï¿½ï¿½ï¿½ï¿½                                            
                    
                                                                                                                                                                                               $    COLOR NORMAL TEXCOORD Main_Pixel                      D         C          C          B            D                                                           HASH       ï¿½Æ›ï¿½KCï¿½ï¿½ï¿½ï¿½_ï¿½I6DXILD  c   ï¿½  DXIL     ,  BCï¿½ï¿½!  ï¿½  ï¿½        ï¿½#ï¿½Aï¿½I29ï¿½ï¿½%ï¿½bï¿½EBï¿½Bï¿½28K
2rï¿½Hï¿½ CFï¿½ï¿½ 2Bï¿½Hï¿½ï¿½#ï¿½PAQï¿½ï¿½ï¿½ï¿½9FQ     ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ m0ï¿½ï¿½ï¿½ï¿½ï¿½ 	ï¿½ I     ï¿½`B L    ï¿½     2"ï¿½	 dï¿½ï¿½#ï¿½ï¿½ï¿½#ã„¡ï¿½Lï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½@	 ï¿½ï¿½# ï¿½9ï¿½ï¿½P ï¿½ï¿½ ï¿½Pï¿½ï¿½ï¿½'ï¿½!$%ï¿½ï¿½ï¿½ï¿½ï¿½Q1*ï¿½3\ï¿½ï¿½=ï¿½ï¿½@3,
ï¿½Qï¿½ï¿½`0 jï¿½a@Ğ£ ï¿½`0)Æ€04)ï¿½ï¿½ï¿½ 
ï¿½ï¿½4\ï¿½ï¿½=ï¿½ä¯„ï¿½ï¿½ï¿½ï¿½6*ï¿½Pï¿½ï¿½A ï¿½)Ä€0ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ËŸï¿½ï¿½ï¿½|nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½5\ï¿½ï¿½=ï¿½ï¿½sUï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½@(Dï¿½ï¿½ ï¿½ï¿½ï¿½`0 ï¿½APï¿½@ ï¿½ï¿½40ï¿½0ï¿½HSD	ï¿½_"ï¿½1!F5PTÂ€0P
fï¿½Æï¿½aï¿½ï¿½
fï¿½ï¿½Æï¿½AÊDï¿½ï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½Ğï¿½ +bï¿½Tï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½Pï¿½@ï¿½ ï¿½ ï¿½
ï¿½ ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½0ï¿½@ï¿½ ï¿½ï¿½Lï¿½8ï¿½C8ï¿½ï¿½<ï¿½-ï¿½>ï¿½C=ï¿½C9ï¿½)ï¿½ï¿½<ï¿½C8ï¿½ï¿½C8ï¿½ï¿½9ï¿½.z
#Cï¿½fï¿½txï¿½yï¿½vï¿½|xï¿½zï¿½7vï¿½yï¿½7ï¿½zï¿½ï¿½zzï¿½y(rï¿½z0s(yï¿½ï¿½vzï¿½ï¿½tï¿½>0vxï¿½pï¿½6 :`0ï¿½? ?@ï¿½ï¿½f3ï¿½ï¿½8ï¿½C8ï¿½ï¿½<ï¿½-ï¿½>ï¿½C=ï¿½C9ï¿½)ï¿½ï¿½<ï¿½C8ï¿½ï¿½C9ï¿½=ï¿½ï¿½<ï¿½:ï¿½;ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½A;ï¿½<ï¿½ï¿½/ï¿½C>ï¿½C9ï¿½ï¿½0ï¿½ï¿½;ï¿½ï¿½<Ìƒï¿½B9ï¿½=Ôƒ<ï¿½ï¿½ï¿½B(Èƒ<ï¿½C>ï¿½ï¿½=ï¿½ï¿½8ï¿½ï¿½;ï¿½ï¿½C8ï¿½ï¿½9ï¿½Ìï¿½ï¿½ AU#ï¿½Ll0ï¿½ï¿½0n@ï¿½ï¿½Pï¿½Pr@
|`ï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`l tï¿½`ï¿½zï¿½ï¿½ï¿½0ï¿½@ï¿½ ï¿½ï¿½La0ï¿½ï¿½0n@ï¿½ï¿½Pï¿½Pr@
|`ï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`l tï¿½`ï¿½Hï¿½ï¿½(7ï¿½;ï¿½ï¿½<Ìƒï¿½B9ï¿½=Ôƒ<ï¿½ï¿½ï¿½ï¿½C9ï¿½=ï¿½ï¿½<ï¿½:ï¿½;ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½A;ï¿½<ï¿½ï¿½/ï¿½C>ï¿½C9ï¿½ï¿½0Sï¿½;ï¿½ï¿½<Ìƒï¿½B9ï¿½=Ôƒ<ï¿½ï¿½ï¿½ï¿½C9ï¿½=ï¿½ï¿½<ï¿½:ï¿½;ï¿½ï¿½ï¿½ï¿½ï¿½T;ï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½Pï¿½@ï¿½ ï¿½ ï¿½ï¿½ï¿½ï¿½`~ï¿½zï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½P( ï¿½Tï¿½;ï¿½ï¿½<Ìƒï¿½B9ï¿½=Ôƒ<ï¿½ï¿½ï¿½ï¿½C8ï¿½ï¿½9ï¿½>ï¿½ï¿½ï¿½mï¿½@4"bï¿½Ø€ï¿½7ï¿½4- ï¿½Pï¿½ï¿½mï¿½ï¿½Y,&#ï¿½ï¿½@Ã›ï¿½)ï¿½ï¿½ï¿½gï¿½Yï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½	Aï¿½# ï¿½)    rï¿½ï¿½t`ï¿½6hï¿½yhrï¿½ï¿½
ï¿½Pmï¿½zPm z0rï¿½s mï¿½qï¿½s mï¿½xï¿½s mï¿½q`z0rï¿½ï¿½0rï¿½s mï¿½v@z`tï¿½ï¿½vï¿½s m`s z0rï¿½ï¿½`tï¿½v@mï¿½xï¿½q`z0rï¿½v@Cï¿½           ï¿½<        y         ï¿½4@        0ï¿½yï¿½        `ï¿½       ï¿½ï¿½g        ï¿½!Oï¿½        Cï¿½       ï¿½<        y8         ï¿½|@        0ï¿½         ï¿½        yï¿½ ï¿½       ï¿½@    2ï¿½Lï¿½ï¿½	&Gï¿½C"ï¿½@D1ï¿½ Fï¿½ï¿½CIAB)Zï¿½ï¿½Jï¿½
aï¿½
ï¿½ï¿½Bï¿½ ï¿½ï¿½ ï¿½mï¿½t3 Ô› ï¿½ 	g ï¿½8@ï¿½ :ï¿½9  ï¿½ï¿½<ï¿½ï¿½<ï¿½ï¿½Pk  y  ï¿½   Lï¿½FDï¿½oï¿½ï¿½M$ï¿½ï¿½Eï¿½fï¿½eï¿½e,ï¿½ï¿½&g&eCLï¿½gï¿½@@ï¿½ï¿½ï¿½ ï¿½a0(ï¿½ï¿½MiÃ€$ï¿½ï¿½ï¿½&m &5A ï¿½
ï¿½ï¿½lHï¿½Yï¿½ï¿½Yï¿½	ï¿½ï¿½ï¿½ï¿½&ÄµAXï¿½
ï¿½ 5ï¿½0LK5A ï¿½	ï¿½ï¿½ï¿½ï¿½6Cï¿½!ï¿½ï¿½f!gï¿½&wï¿½ï¿½kï¿½kï¿½ï¿½jï¿½@h=Hï¿½
ï¿½ï¿½5ï¿½7\K5A ï¿½	Bï¿½ï¿½ï¿½$Ä Yï¿½`ï¿½ï¿½jï¿½ 
kï¿½!IÈ Yï¿½ï¿½Zï¿½
Gdmï¿½ALDï¿½
&ï¿½YÎ Yï¿½
ï¿½	)ï¿½ï¿½ï¿½ï¿½6 ï¿½4ï¿½0ï¿½ï¿½AH6ï¿½ ï¿½ï¿½l@7hï¿½eXï¿½
ï¿½ï¿½ï¿½2ï¿½Ax8ï¿½@ï¿½ï¿½q0A8ï¿½7ï¿½ï¿½ï¿½A ï¿½4ï¿½ï¿½ï¿½}Aï¿½á•±qï¿½ï¿½ï¿½ï¿½zï¿½Kï¿½K{sï¿½ ï¿½ï¿½ ï¿½
ï¿½2A(ï¿½`ï¿½Pï¿½ï¿½ï¿½eï¿½<ï¿½=Øƒa> X=1=IMï¿½1ï¿½ Ó†eï¿½<ï¿½=ï¿½ï¿½!> NORMALï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½<ï¿½ï¿½ ï¿½Pa
==Imbï¿½Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½BaLï¿½É”ï¿½Uï¿½ï¿½Yï¿½ï¿½ ï¿½	ï¿½mUØ°,ï¿½ï¿½ï¿½ï¿½|0ï¿½ï¿½ï¿½ï¿½ï¿½!`ï¿½
ï¿½)ï¿½0A@ï¿½2ï¿½ ,ï¿½ï¿½ï¿½ï¿½;p9ï¿½ï¿½*llvm.identSï¿½ï¿½
ï¿½ï¿½]ï¿½ï¿½\Ú›Û”ï¿½hBï¿½ï¿½bï¿½fW&7%0ï¿½ï¿½Ì¡ï¿½ï¿½ï¿½ï¿½5ï¿½ï¿½ï¿½ï¿½M	ï¿½2dx.resourcesSï¿½8ï¿½Cï¿½ï¿½bï¿½Vvï¿½D6EFW6%ï¿½ï¿½:dx.entryPointsSX  y  Q   3ï¿½ï¿½ï¿½f=ï¿½C8ï¿½ÃŒBï¿½yxsï¿½qï¿½ ï¿½ï¿½3Bï¿½ï¿½Î¡f0=ï¿½C8ï¿½ï¿½ï¿½=ï¿½C=ï¿½=ï¿½xï¿½tp{yHï¿½ppzpvxï¿½p ï¿½ï¿½ï¿½ï¿½0n0ï¿½ï¿½ï¿½P3ï¿½ï¿½!ï¿½!ï¿½af0ï¿½;ï¿½ï¿½;ï¿½C9ï¿½<ï¿½ï¿½<ï¿½;ï¿½ï¿½v`{h7hï¿½rh7ï¿½ï¿½pï¿½ï¿½p`v(vï¿½vxï¿½wï¿½ï¿½_ï¿½qï¿½rï¿½ï¿½yï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0bÈ¡ï¿½Ì¡ï¿½ï¿½aï¿½!Äï¿½aÖC9ï¿½C9ï¿½C9ï¿½C9ï¿½ï¿½8ï¿½C8ï¿½;ï¿½ï¿½/ï¿½ï¿½<ï¿½ï¿½;ï¿½;ï¿½ï¿½ï¿½!|pz(ï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½0ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½aï¿½@ï¿½   q   =   ï¿½ï¿½ ï¿½ï¿½)rï¿½%@ï¿½ï¿½;ï¿½ 
a~qÛ¦ 
ï¿½ï¿½<~ï¿½4@ï¿½ï¿½ï¿½mï¿½ï¿½6\ï¿½ï¿½ï¿½B@ï¿½0ï¿½ï¿½ï¿½_Ü¶1lï¿½ï¿½;ï¿½/TQQï¿½ CIï¿½ï¿½ï¿½ï¿½mï¿½ï¿½4\ï¿½ï¿½ï¿½BD Í°fï¿½ï¿½ï¿½<ï¿½ï¿½Lï¿½_Ü¶8ï¿½ï¿½;ï¿½?8ï¿½ï¿½ï¿½mï¿½pï¿½ï¿½ï¿½/0ï¿½ï¿½CM~qï¿½vp
ï¿½ï¿½<~XUDT:ï¿½ï¿½ï¿½mï¿½pï¿½ï¿½ï¿½Gï¿½ï¿½QEADï¿½>rï¿½6 
ï¿½ï¿½<ï¿½0ï¿½Bï¿½ï¿½mï¿½@5\ï¿½ï¿½ï¿½ï¿½ï¿½DJM5ï¿½ï¿½m[ï¿½4\ï¿½ï¿½ï¿½Ma~qï¿½Fï¿½ï¿½ï¿½<>ï¿½ ï¿½ï¿½
  a   ï¿½  U,   *   dï¿½B9ï¿½G	ï¿½ï¿½
ï¿½Øªï¿½ï¿½
ï¿½ï¿½Jï¿½ï¿½
ï¿½,
5ï¿½L
ï¿½,ï¿½ï¿½ï¿½f Jï¿½ï¿½
ï¿½ï¿½Êˆcï¿½9ï¿½7F ï¿½ ï¿½sc ï¿½`7F ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½c ï¿½tï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
cï¿½Lï¿½p7FĞšsN{c ï¿½2ï¿½ï¿½ ï¿½ï¿½0F ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½`00F ï¿½ ï¿½#     #	 ï¿½`pï¿½pï¿½+ï¿½Bï¿½$ ï¿½ï¿½ï¿½ï¿½ï¿½@
n0bï¿½  g ï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½Aï¿½ ï¿½ï¿½,hï¿½ #	 ï¿½`pï¿½ï¿½ï¿½ï¿½*ï¿½Bï¿½$ ï¿½ï¿½ï¿½
ï¿½@r0bï¿½  g`ï¿½(ï¿½B,ï¿½ï¿½ï¿½Aï¿½ ï¿½ï¿½-xï¿½`ï¿½@#	 ï¿½`pï¿½ï¿½ï¿½,ï¿½Bï¿½$ ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½$ ï¿½ï¿½ï¿½Bï¿½B-ï¿½ï¿½ï¿½$ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½p
c0bï¿½  F:ï¿½ï¿½.Ü‚ï¿½ï¿½ï¿½Aï¿½ ï¿½ï¿½ï¿½ï¿½P#	 ï¿½``ï¿½ï¿½,ï¿½B.ï¿½ï¿½ï¿½$ ï¿½ï¿½ï¿½ï¿½Pï¿½ï¿½
g0bï¿½  F;ï¿½ï¿½/ï¿½+ï¿½ï¿½ï¿½Aï¿½ ï¿½Pï¿½ï¿½{ï¿½#	 ï¿½``ï¿½ï¿½-ï¿½C/ï¿½ï¿½ï¿½ ï¿½ï¿½giï¿½ï¿½ï¿½hB ï¿½&ï¿½hï¿½ ï¿½1ï¿½Ç!>vï¿½aï¿½ï¿½
ï¿½|Lï¿½c!ï¿½ï¿½ ï¿½ï¿½ï¿½{ï¿½ï¿½1%ï¿½ï¿½)ï¿½|Lï¿½3bï¿½  Q?ï¿½ï¿½ ï¿½Uï¿½ï¿½10 ï¿½$ï¿½!ï¿½ï¿½ï¿½ï¿½	ï¿½|l0ï¿½3bï¿½  ï¿½Hï¿½ï¿½ ï¿½ï¿½ï¿½!>Fï¿½10 ï¿½%Vï¿½10 ï¿½'%Xï¿½10 ï¿½G%Zï¿½10 ï¿½g%^!F ï¿½ï¿½a	Xï¿½ A0xZ"ï¿½ï¿½C>fï¿½@ï¿½ï¿½ï¿½|Lï¿½3b`  ï¿½Lï¿½B`|ï¿½ï¿½E>ï¿½(ï¿½@ï¿½ï¿½-ï¿½|Lï¿½3b`  ï¿½Nï¿½B`ï¿½ï¿½gï¿½ï¿½ @ï¿½ï¿½ï¿½;10 ï¿½ï¿½'ï¿½ï¿½Lï¿½ï¿½cï¿½%c,ï¿½ï¿½, ï¿½Aï¿½ï¿½mï¿½ ï¿½1ï¿½ï¿½Ïˆï¿½ï¿½ <dï¿½0b`  OYï¿½ï¿½Ø²ï¿½Ç˜M>ï¿½lï¿½1X ï¿½-Ğï¿½@!ï¿½ï¿½ï¿½ï¿½	ï¿½|LPï¿½cï¿½ï¿½ï¿½pï¿½ï¿½ï¿½|Lï¿½3KTpï¿½A0P1ï¿½pï¿½@ï¿½*ï¿½&ï¿½ ï¿½cAï¿½Ç„:ï¿½ï¿½
u #ï¿½Xï¿½ï¿½ï¿½[ï¿½ï¿½	ï¿½ ï¿½ï¿½ A0hï¿½ï¿½Æï¿½ï¿½ï¿½ï¿½-ï¿½bï¿½a4! ï¿½ï¿½ï¿½Xï¿½ï¿½1X ï¿½4@bQ]ï¿½\10 ï¿½G4ï¿½"ï¿½ï¿½nxï¿½`ï¿½aï¿½ï¿½ï¿½ï¿½
A^ï¿½ï¿½,ï¿½#	 ï¿½`0ï¿½FM<ï¿½ï¿½ ï¿½ï¿½ï¿½1Xï¿½ï¿½@ï¿½ï¿½Iï¿½ ï¿½ï¿½0ï¿½Ç„	># ï¿½`ï¿½Ä†Jï¿½ï¿½;A>ï¿½Chï¿½ï¿½Kï¿½ï¿½hB ï¿½&ï¿½hï¿½ ï¿½&Ãˆï¿½ï¿½ 4ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½`ï¿½1ï¿½0ï¿½ ï¿½	B0ï¿½06ï¿½ï¿½|,0	ï¿½Qï¿½ %ï¿½3bï¿½  d@=aï¿½0bï¿½  dP>aFIï¿½  ï¿½ï¿½ï¿½Oï¿½ï¿½aFï¿½1X ï¿½<ï¿½ï¿½ï¿½H	ï¿½ï¿½ï¿½ï¿½3bp  ï¿½oï¿½Dï¿½# ï¿½`ï¿½ï¿½FO+a-ï¿½Ç‚!># ï¿½`ï¿½ï¿½ï¿½Xï¿½nï¿½&ï¿½hï¿½ï¿½&ï¿½
ï¿½|lHï¿½cï¿½"ï¿½ï¿½ A0ï¿½ï¿½C-TB7F`4AFï¿½G>6<ï¿½ï¿½ï¿½
|lPï¿½cï¿½ï¿½ï¿½ A0ï¿½ï¿½.hï¿½=F`4AFï¿½K>6\ï¿½ï¿½ï¿½)|Lï¿½cï¿½ ï¿½ï¿½ A0ï¿½ï¿½ï¿½ï¿½8ï¿½Ñ„@nï¿½fï¿½!ï¿½% *ï¿½Tbï¿½aï¿½bH%ï¿½*ï¿½Tbï¿½aï¿½ï¿½H%F~ï¿½ A0ï¿½LD5ï¿½"Ğİ˜ï¿½Ñ„ Mï¿½Ñ„A1P ï¿½JE\ï¿½-ï¿½ï¿½ï¿½ï¿½Mï¿½ A0ï¿½X6ï¿½â¨ï¿½ÈÑ„ Mï¿½Ñ„A1P ï¿½Ehc.ï¿½ï¿½ï¿½ï¿½Mï¿½ A0ï¿½dï¿½6ï¿½ï¿½ï¿½ï¿½ï¿½Ñ„ Mï¿½Ñ„A1P ï¿½Ft#/"ï¿½Hï¿½Mï¿½ A0ï¿½pï¿½7ï¿½bï¿½ï¿½(ï¿½Ñ„ 1P ,G|ï¿½/ï¿½ï¿½hï¿½Mï¿½ A0ï¿½x<ï¿½ï¿½Êï¿½Hï¿½Ñ„ 1P ï¿½ï¿½Gï¿½#42ï¿½ï¿½Mï¿½ï¿½!Mï¿½6ï¿½ï¿½ï¿½Ç²M>ï¿½
ï¿½ï¿½ï¿½,ï¿½Q#
 ï¿½`Pï¿½ï¿½zï¿½Fï¿½G~ï¿½ï¿½hB Xhlï¿½ï¿½ï¿½ï¿½cï¿½ï¿½ï¿½gï¿½`@ï¿½6iï¿½A!0%ï¿½ï¿½)}Lï¿½3b`  ï¿½ï¿½ï¿½a"ï¿½Ø€ï¿½gï¿½Aï¿½F ï¿½ ï¿½ï¿½0ï¿½ï¿½Aï¿½ï¿½!ï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½Xï¿½ï¿½ï¿½Xï¿½Ycï¿½bï¿½ï¿½(*8 ï¿½bï¿½bï¿½ï¿½(*Z ï¿½bï¿½bï¿½B+*Z ï¿½bï¿½`@"Qï¿½AÌ¡ï¿½ï¿½ï¿½#ï¿½Ïˆï¿½ï¿½ hï¿½ï¿½{Xï¿½ï¿½Ç„D>6$ï¿½18 ï¿½OTJï¿½<ï¿½d4! Fï¿½`4al<ï¿½ï¿½ï¿½xï¿½ï¿½ï¿½cï¿½ ï¿½ï¿½ï¿½ï¿½B>&ï¿½10 ï¿½ï¿½Vn$ï¿½ Dï¿½cï¿½ï¿½ï¿½ÂŒ ï¿½7+hï¿½Aï¿½ ï¿½ï¿½!ï¿½ï¿½ï¿½ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½ï¿½>6ï¿½|lï¿½ï¿½ï¿½ï¿½ï¿½)%Wnï¿½@@*q1ï¿½	lï¿½N^e4! Fï¿½`4aFï¿½aï¿½@@ï¿½sY1ï¿½dOhe4! Fï¿½`4aFï¿½aï¿½@@*vï¿½ï¿½Yï¿½Tre4! Fï¿½`4aFï¿½aï¿½@@ï¿½xï¿½ï¿½ï¿½ï¿½T|e4! Fï¿½`4aFï¿½ï¿½&L># ï¿½`@ï¿½'ï¿½  ï¿½ï¿½Ë,X`ï¿½ï¿½8ï¿½ï¿½  ï¿½Ô‹ï¿½H\0bï¿½  d`/ï¿½pï¿½
t,ï¿½ï¿½  ï¿½ä‹¨T`ï¿½  ï¿½ï¿½Ë¨D`Xï¿½@ï¿½82ï¿½Ïˆï¿½ ï¿½Aï¿½ï¿½
Fï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
Eï¿½tï¿½	ï¿½cï¿½@;ï¿½ï¿½@'ï¿½:ï¿½cBï¿½ï¿½ï¿½=ï¿½ï¿½	ï¿½L>ï¿½ï¿½1x ï¿½ï¿½fZï¿½Nï¿½d>!ï¿½ï¿½>Mï¿½ï¿½@ï¿½ï¿½?ï¿½ï¿½ï¿½Vï¿½ï¿½%ï¿½ï¿½ï¿½ A0htfVï¿½ï¿½Nï¿½ï¿½ï¿½Qï¿½[ï¿½Ñ„ ï¿½ ï¿½n ï¿½Q	,8ï¿½cAï¿½ï¿½gï¿½ï¿½B
ï¿½e8ï¿½ï¿½*Yï¿½ï¿½Uï¿½"ï¿½bE>&+C|lVï¿½ï¿½ï¿½ï¿½18 Mlï¿½ï¿½F ï¿½@ï¿½q1ï¿½ï¿½ A0ï¿½È†\ï¿½aï¿½ï¿½ @ï¿½ï¿½)ï¿½AVF ï¿½@3sfeï¿½ï¿½ @ï¿½ï¿½9ï¿½ï¿½VF ï¿½@Ctï¿½ï¿½ A0ï¿½ï¿½&]ï¿½n%ï¿½Ïˆï¿½ï¿½ hkï¿½.ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½6ï¿½ï¿½ï¿½
ï¿½X`ï¿½gï¿½ ï¿½ï¿½ï¿½
{ï¿½@>ï¿½ï¿½|Lï¿½ï¿½T-ï¿½Í( ï¿½Au7ï¿½ï¿½+ï¿½Ú¬ÙŒ&ï¿½hï¿½ï¿½&Âˆï¿½ï¿½ T{ï¿½/ï¿½Rï¿½ï¿½Ë ï¿½hB ï¿½&ï¿½hï¿½ ï¿½( ï¿½Aï¿½7#C.Iï¿½ï¿½ÛŒ&ï¿½hï¿½ï¿½&Âˆï¿½ï¿½ Tï¿½s2ï¿½Ò¼ï¿½ï¿½ï¿½ï¿½hB ï¿½&ï¿½hï¿½ 9ï¿½ï¿½|F ï¿½ï¿½Dgeï¿½ï¿½ï¿½ A0 ï¿½ï¿½a^`ï¿½ï¿½\ï¿½ï¿½ï¿½<ï¿½gï¿½ @ï¿½ï¿½t^fï¿½!1@ 28ï¿½ï¿½x,ï¿½ï¿½X:Ğƒ|F ï¿½ï¿½TgfÊï¿½ A0 ï¿½Õ¡ï¿½pï¿½ï¿½ï¿½ï¿½^ï¿½ï¿½%}ï¿½ï¿½cï¿½ï¿½ï¿½BFï¿½ï¿½	%#LF>ï¿½ï¿½@ï¿½`bHH,ï¿½ï¿½!%ï¿½\00bF>ï¿½%P*%ï¿½eï¿½ï¿½ï¿½ï¿½ï¿½fï¿½ï¿½ï¿½Ç‚>ï¿½ï¿½1x ï¿½}ï¿½FeJF8ï¿½ï¿½ï¿½)ï¿½Mï¿½ï¿½!MjF>6ØŒ|lï¿½ï¿½Ø 3ï¿½agï¿½cï¿½ï¿½gï¿½ï¿½@ï¿½Yï¿½y&ZtF|ï¿½ï¿½mtf4! ï¿½ï¿½ï¿½X 6ï¿½ï¿½gï¿½c>ï¿½ï¿½>ï¿½Ïˆï¿½ ï¿½ï¿½ï¿½ï¿½Mï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½s ;ï¿½@># ï¿½`@ï¿½ï¿½7|`# ï¿½`@ï¿½ï¿½7yï¿½ï¿½tlï¿½ï¿½  ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½  ï¿½ï¿½Oï¿½ï¿½ï¿½Xï¿½Ğ±d>ï¿½cï¿½|ï¿½Ç†ï¿½ï¿½ï¿½
ï¿½|lï¿½cï¿½ #ï¿½ï¿½ï¿½gï¿½ï¿½ @ï¿½jï¿½ï¿½ï¿½ï¿½>ï¿½ï¿½ï¿½dï¿½Ïˆï¿½ï¿½ D.ï¿½:ï¿½ï¿½|ï¿½7A|F ï¿½@c!ï¿½	ï¿½fï¿½`@ï¿½ï¿½ï¿½ï¿½iï¿½ï¿½ï¿½ï¿½ï¿½cuaï¿½ï¿½ï¿½bï¿½Ïˆï¿½ï¿½ D5T;ï¿½B`A!;ï¿½ï¿½, ï¿½Aï¿½Cï¿½cï¿½ï¿½ï¿½
ï¿½Gï¿½C|ï¿½
ï¿½ï¿½ï¿½|ldï¿½
ï¿½
ï¿½ï¿½,Ã¢&
4ï¿½á†€ï¿½ï¿½`ï¿½ï¿½Iï¿½
vï¿½ï¿½=cï¿½ï¿½ï¿½ï¿½ï¿½Ç‚D>ï¿½ï¿½|Lï¿½ï¿½ï¿½ï¿½#ï¿½cï¿½ï¿½ï¿½ï¿½ Cï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½Qï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½pï¿½ï¿½ï¿½,ï¿½ï¿½ï¿½@ï¿½ Nï¿½ï¿½Tï¿½$8ï¿½@ï¿½ Nï¿½ÓŒ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½&ï¿½hï¿½7ï¿½2<T0K 
Tï¿½ 9ï¿½@ï¿½ï¿½ï¿½Tï¿½ 9ï¿½@ï¿½( ï¿½Aï¿½Gï¿½ï¿½;ï¿½Pï¿½&ï¿½hï¿½ï¿½&Âˆï¿½ï¿½ T|Bï¿½Sï¿½ï¿½ï¿½ï¿½hB ï¿½( ï¿½Aï¿½G">ï¿½	ï¿½ï¿½ï¿½( ï¿½ï¿½G#$>ï¿½ï¿½&ï¿½ï¿½ï¿½ï¿½ Tï¿½TBä£¬ï¿½
ï¿½ï¿½hB ï¿½&ï¿½hï¿½ ï¿½ï¿½ï¿½F>ï¿½0ï¿½n@ï¿½fï¿½(1P ï¿½*ï¿½Zï¿½}ï¿½ï¿½!;Mï¿½Ñ„FMpï¿½Ñ„ï¿½ï¿½	ï¿½cï¿½3ï¿½ï¿½Î§ï¿½Ïˆï¿½ï¿½ Dï¿½4Cï¿½B`M@kï¿½X3ï¿½gï¿½ï¿½ @\#ï¿½D>& ï¿½ï¿½ï¿½pCK`0bï¿½  /ï¿½vYï¿½ Gï¿½ï¿½ï¿½tï¿½	-ï¿½t
-ï¿½tC
-ï¿½,ï¿½4P1ï¿½dDï¿½@F4P1ï¿½dDï¿½(@Z4P1ï¿½ï¿½Eï¿½(@Z4bï¿½  :ï¿½ï¿½ ,ï¿½2)c7ï¿½gï¿½ï¿½ @4s"ï¿½@ï¿½,Hï¿½cB"ï¿½Ø€ï¿½ï¿½cï¿½ï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ @ï¿½`ï¿½ï¿½ï¿½ï¿½h4!ï¿½ï¿½ï¿½fï¿½)ï¿½%ï¿½*ï¿½pï¿½iï¿½b`	Ç™*ï¿½pï¿½ï¿½ï¿½ï¿½ï¿½
h#ï¿½F>#	 ï¿½`ï¿½ï¿½S9ï¿½S;ï¿½ï¿½0bï¿½  ï¿½?ï¿½S;ï¿½+	#	 ï¿½`ï¿½ï¿½S9ï¿½S;ï¿½R0bï¿½  ï¿½?ï¿½S;ï¿½8ï¿½
       DXBCï¿½ï¿½ï¿½ï¿½ß°ï¿½ï¿½.3ï¿½\ï¿½f   l      8   H   d  ï¿½  $  @  SFI0           ISG1            ï¿½                            ï¿½                           ï¿½                                                                               
                          ï¿½                      SV_Position COLOR NORMAL TEXCOORD TANGENT   OSG14             (       @                 SV_Target   PSV0|  4                       ï¿½ï¿½ï¿½ï¿½                    /                        
                    
                                                                                                                                                                                               @    COLOR NORMAL TEXCOORD TANGENT NORMAL TEXCOORD Main_Pixel_Ext                         D         C          C          B          C         C   &      b            D                                                                                     HASH       ï¿½vï¿½P Rï¿½@
ï¿½ï¿½ï¿½ï¿½DXIL$  c   	  DXIL       BCï¿½ï¿½!     ï¿½        ï¿½#ï¿½Aï¿½I29ï¿½ï¿½%ï¿½bï¿½EBï¿½Bï¿½28K
2rï¿½Hï¿½ CFï¿½ï¿½ 2Bï¿½Hï¿½ï¿½#ï¿½PAQï¿½ï¿½ï¿½ï¿½9FQ     ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ m0ï¿½ï¿½ï¿½ï¿½ï¿½ 	ï¿½ I     ï¿½`B L    ï¿½     2"ï¿½	 dï¿½ï¿½#ï¿½ï¿½ï¿½#ã„¡ï¿½Lï¿½ï¿½ï¿½ï¿½Lï¿½ï¿½@	 ï¿½ï¿½# ï¿½9ï¿½ï¿½P ï¿½ï¿½ ï¿½Pï¿½ï¿½ï¿½'ï¿½!$%ï¿½ï¿½ï¿½ï¿½ï¿½Q1*ï¿½3\ï¿½ï¿½=ï¿½ï¿½@3,
ï¿½Qï¿½ï¿½`0 jï¿½a@Ğ£ ï¿½`0)Æ€04)ï¿½ï¿½ï¿½ 
ï¿½ï¿½4\ï¿½ï¿½=ï¿½ä¯„ï¿½ï¿½ï¿½ï¿½6*ï¿½Pï¿½ï¿½A ï¿½)Ä€0ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½ËŸï¿½ï¿½ï¿½|nï¿½ï¿½ï¿½ï¿½ï¿½ï¿½1ï¿½ï¿½ï¿½5\ï¿½ï¿½=ï¿½ï¿½sUï¿½ï¿½ï¿½#ï¿½ï¿½ï¿½@(Dï¿½ï¿½ ï¿½ï¿½ï¿½`0 ï¿½APï¿½@ ï¿½ï¿½40ï¿½0ï¿½HSD	ï¿½_"ï¿½1!F5PTÂ€0P
fï¿½Æï¿½aï¿½ï¿½
fï¿½ï¿½Æï¿½AÊDï¿½ï¿½ï¿½ï¿½Aï¿½ï¿½ï¿½ï¿½Ğï¿½ +bï¿½Tï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½Pï¿½@ï¿½ ï¿½ ï¿½
ï¿½ ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½zï¿½ï¿½ï¿½0ï¿½@ï¿½ ï¿½ï¿½Lï¿½8ï¿½C8ï¿½ï¿½<ï¿½-ï¿½>ï¿½C=ï¿½C9ï¿½)ï¿½ï¿½<ï¿½C8ï¿½ï¿½C8ï¿½ï¿½9ï¿½.z
#Cï¿½fï¿½txï¿½yï¿½vï¿½|xï¿½zï¿½7vï¿½yï¿½7ï¿½zï¿½ï¿½zzï¿½y(rï¿½z0s(yï¿½ï¿½vzï¿½ï¿½tï¿½>0vxï¿½pï¿½6 :`0ï¿½? ?@ï¿½ï¿½f3ï¿½ï¿½8ï¿½C8ï¿½ï¿½<ï¿½-ï¿½>ï¿½C=ï¿½C9ï¿½)ï¿½ï¿½<ï¿½C8ï¿½ï¿½C9ï¿½=ï¿½ï¿½<ï¿½:ï¿½;ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½A;ï¿½<ï¿½ï¿½/ï¿½C>ï¿½C9ï¿½ï¿½0ï¿½ï¿½;ï¿½ï¿½<Ìƒï¿½B9ï¿½=Ôƒ<ï¿½ï¿½ï¿½B(Èƒ<ï¿½C>ï¿½ï¿½=ï¿½ï¿½8ï¿½ï¿½;ï¿½ï¿½C8ï¿½ï¿½9ï¿½Ìï¿½ï¿½ AU#ï¿½Ll0ï¿½ï¿½0n@ï¿½ï¿½Pï¿½Pr@
|`ï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`l tï¿½`ï¿½zï¿½ï¿½ï¿½0ï¿½@ï¿½ ï¿½ï¿½La0ï¿½ï¿½0n@ï¿½ï¿½Pï¿½Pr@
|`ï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`l tï¿½`ï¿½Hï¿½ï¿½(7ï¿½;ï¿½ï¿½<Ìƒï¿½B9ï¿½=Ôƒ<ï¿½ï¿½ï¿½ï¿½C9ï¿½=ï¿½ï¿½<ï¿½:ï¿½;ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½A;ï¿½<ï¿½ï¿½/ï¿½C>ï¿½C9ï¿½ï¿½0Sï¿½;ï¿½ï¿½<Ìƒï¿½B9ï¿½=Ôƒ<ï¿½ï¿½ï¿½ï¿½C9ï¿½=ï¿½ï¿½<ï¿½:ï¿½;ï¿½ï¿½ï¿½ï¿½ï¿½T;ï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½Pï¿½@ï¿½ ï¿½ ï¿½ï¿½ï¿½ï¿½`~ï¿½zï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½P( ï¿½Tï¿½;ï¿½ï¿½<Ìƒï¿½B9ï¿½=Ôƒ<ï¿½ï¿½ï¿½ï¿½C8ï¿½ï¿½9ï¿½>ï¿½ï¿½ï¿½mï¿½@4"bï¿½Ø€ï¿½7ï¿½4- ï¿½Pï¿½ï¿½mï¿½ï¿½Y,&#ï¿½ï¿½@Ã›ï¿½)ï¿½ï¿½ï¿½gï¿½Yï¿½ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½Aï¿½# ï¿½)    rï¿½ï¿½t`ï¿½6hï¿½yhrï¿½ï¿½
ï¿½Pmï¿½zPm z0rï¿½s mï¿½qï¿½s mï¿½xï¿½s mï¿½q`z0rï¿½ï¿½0rï¿½s mï¿½v@z`tï¿½ï¿½vï¿½s m`s z0rï¿½ï¿½`tï¿½v@mï¿½xï¿½q`z0rï¿½v@Cï¿½           ï¿½<        y         ï¿½4@        0ï¿½yï¿½        `ï¿½       ï¿½ï¿½g        ï¿½!Oï¿½        Cï¿½       ï¿½<        y8         ï¿½|@        0ï¿½         ï¿½        yï¿½ ï¿½       ï¿½@    2ï¿½Lï¿½ï¿½	&Gï¿½C"ï¿½@D1ï¿½ Fï¿½ï¿½CIAB)Zï¿½ï¿½Jï¿½
aï¿½
ï¿½ï¿½Bï¿½ ï¿½ï¿½ ï¿½mï¿½t3 Ô› ï¿½ 	g ï¿½8@ï¿½ :ï¿½ï¿½]  ï¿½ï¿½<ï¿½ï¿½<ï¿½ï¿½ ï¿½qï¿½qÔš   y  ï¿½   Lï¿½FDï¿½oï¿½ï¿½M$ï¿½ï¿½Eï¿½fï¿½eï¿½e,ï¿½ï¿½&g&eCLï¿½gï¿½@@ï¿½ï¿½ï¿½ ï¿½a0(ï¿½ï¿½MiÃ€$ï¿½ï¿½ï¿½&m &5A ï¿½
ï¿½ï¿½lHï¿½Yï¿½ï¿½Yï¿½	ï¿½ï¿½ï¿½ï¿½&ÄµAXï¿½
ï¿½ 5ï¿½0LK5A ï¿½	ï¿½ï¿½ï¿½ï¿½6Cï¿½!ï¿½ï¿½f!gï¿½&wï¿½ï¿½kï¿½kï¿½ï¿½jï¿½@h=Hï¿½
ï¿½ï¿½5ï¿½7\K5A ï¿½	Bï¿½ï¿½ï¿½$Ä Yï¿½`ï¿½ï¿½jï¿½ 
kï¿½!IÈ Yï¿½ï¿½Zï¿½
Gdmï¿½ALDï¿½
&ï¿½YÎ Yï¿½
ï¿½	)ï¿½ï¿½ï¿½ï¿½6 ï¿½4ï¿½0ï¿½ï¿½AH6ï¿½ ï¿½ï¿½l@7hï¿½eXï¿½
ï¿½ï¿½ï¿½2ï¿½Ax8ï¿½@ï¿½ï¿½q0A8ï¿½7ï¿½ï¿½ï¿½A ï¿½4ï¿½ï¿½ï¿½}Aï¿½á•±}ï¿½ï¿½qï¿½ï¿½ï¿½ï¿½zï¿½Kï¿½K{sï¿½ ï¿½ï¿½ ï¿½
ï¿½2A(ï¿½`ï¿½Pï¿½ï¿½ï¿½eï¿½<ï¿½=Øƒa> X=1=IMï¿½1ï¿½ Ó†eï¿½<ï¿½=ï¿½ï¿½!> NORMALï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½<ï¿½ï¿½ ï¿½Pa
==Imbï¿½Bï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½"'ï¿½
ï¿½w
xï¿½zï¿½Cx| 
ï¿½aï¿½ï¿½ï¿½|ï¿½
0ï¿½Aï¿½(lXRï¿½>Hï¿½?ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½0
ï¿½ï¿½
ï¿½ï¿½
Lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½&Loï¿½@ï¿½Â†ei<p=ï¿½ï¿½a>ï¿½ï¿½
A,lXAï¿½	*ï¿½ï¿½aï¿½ï¿½
Eï¿½ï¿½,ï¿½A-Tacï¿½ksI#+sï¿½ï¿½Uï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ü¦D2<ï¿½06ï¿½2ï¿½)ï¿½Qï¿½ï¿½e-ï¿½ï¿½Lï¿½é¬ï¿½mJï¿½ï¿½!ï¿½sï¿½+ï¿½{ï¿½ï¿½+ï¿½ï¿½ï¿½A2<ï¿½ï¿½ï¿½ï¿½$ï¿½)ï¿½0ï¿½ï¿½)ï¿½ï¿½!ï¿½s)sï¿½ï¿½ËƒzKsï¿½ï¿½ï¿½ï¿½ y  Q   3ï¿½ï¿½ï¿½f=ï¿½C8ï¿½ÃŒBï¿½yxsï¿½qï¿½ ï¿½ï¿½3Bï¿½ï¿½Î¡f0=ï¿½C8ï¿½ï¿½ï¿½=ï¿½C=ï¿½=ï¿½xï¿½tp{yHï¿½ppzpvxï¿½p ï¿½ï¿½ï¿½ï¿½0n0ï¿½ï¿½ï¿½P3ï¿½ï¿½!ï¿½!ï¿½af0ï¿½;ï¿½ï¿½;ï¿½C9ï¿½<ï¿½ï¿½<ï¿½;ï¿½ï¿½v`{h7hï¿½rh7ï¿½ï¿½pï¿½ï¿½p`v(vï¿½vxï¿½wï¿½ï¿½_ï¿½qï¿½rï¿½ï¿½yï¿½ï¿½,ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0bÈ¡ï¿½Ì¡ï¿½ï¿½aï¿½!Äï¿½aÖC9ï¿½C9ï¿½C9ï¿½C9ï¿½ï¿½8ï¿½C8ï¿½;ï¿½ï¿½/ï¿½ï¿½<ï¿½ï¿½;ï¿½;ï¿½ï¿½ï¿½!|pz(ï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Pï¿½0ï¿½ï¿½ï¿½ï¿½@ï¿½ï¿½aï¿½@ï¿½   q   >   ï¿½ï¿½ ï¿½ï¿½)rï¿½ï¿½]ï¿½%@ï¿½ï¿½;ï¿½ 
a~qÛ¦ 
ï¿½ï¿½<~ï¿½4@ï¿½ï¿½ï¿½mï¿½ï¿½6\ï¿½ï¿½ï¿½B@ï¿½0ï¿½ï¿½ï¿½_Ü¶1lï¿½ï¿½;ï¿½/TQQï¿½ CIï¿½ï¿½ï¿½ï¿½mï¿½ï¿½4\ï¿½ï¿½ï¿½BD Í°fï¿½ï¿½ï¿½<ï¿½ï¿½Lï¿½_Ü¶8ï¿½ï¿½;ï¿½?8ï¿½ï¿½ï¿½mï¿½pï¿½ï¿½ï¿½/0ï¿½ï¿½CM~qï¿½vp
ï¿½ï¿½<~XUDT:ï¿½ï¿½ï¿½mï¿½pï¿½ï¿½ï¿½Gï¿½ï¿½QEADï¿½>rï¿½6 
ï¿½ï¿½<ï¿½0ï¿½Bï¿½ï¿½mï¿½@5\ï¿½ï¿½ï¿½ï¿½ï¿½DJM5ï¿½ï¿½m[ï¿½4\ï¿½ï¿½ï¿½Ma~qï¿½Fï¿½ï¿½ï¿½<>ï¿½ ï¿½ï¿½
   a     U,   *   dï¿½B9ï¿½G	ï¿½ï¿½
ï¿½Øªï¿½ï¿½
ï¿½ï¿½Jï¿½ï¿½
ï¿½,
5ï¿½L
ï¿½ï¿½ï¿½R`ï¿½ï¿½Jï¿½ï¿½
ï¿½ï¿½Êˆcï¿½9ï¿½7F ï¿½ ï¿½sc ï¿½`7F ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½c ï¿½tï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½
cï¿½Lï¿½p7FĞšsN{c ï¿½2ï¿½ï¿½ ï¿½ï¿½0F ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½`000F ï¿½ ï¿½    #	 ï¿½`pï¿½pï¿½+ï¿½Bï¿½$ ï¿½ï¿½ï¿½ï¿½ï¿½@
n0bï¿½  g ï¿½ï¿½ï¿½)ï¿½ï¿½ï¿½Aï¿½ ï¿½ï¿½,hï¿½ #	 ï¿½`pï¿½ï¿½ï¿½ï¿½*ï¿½Bï¿½$ ï¿½ï¿½ï¿½
ï¿½@r0bï¿½  g`ï¿½(ï¿½B,ï¿½ï¿½ï¿½Aï¿½ ï¿½ï¿½-xï¿½`ï¿½@#	 ï¿½`pï¿½ï¿½ï¿½,ï¿½Bï¿½$ ï¿½ï¿½ï¿½ï¿½.ï¿½ï¿½ï¿½$ ï¿½ï¿½ï¿½Bï¿½B-ï¿½ï¿½ï¿½$ ï¿½ï¿½ï¿½ï¿½ï¿½
ï¿½p
d0bï¿½  F:ï¿½ï¿½+ï¿½ï¿½)ï¿½ï¿½ï¿½Aï¿½ ï¿½ï¿½ï¿½w`#	 ï¿½``ï¿½ï¿½,ï¿½B.ï¿½ï¿½ï¿½$ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½h0bï¿½  F;Ğ‚-ï¿½+ï¿½ï¿½ï¿½Aï¿½ ï¿½Pï¿½ï¿½{ï¿½#	 ï¿½``ï¿½ï¿½-ï¿½B/ï¿½ï¿½ï¿½$ ï¿½ï¿½ï¿½ ï¿½ï¿½
l0bï¿½  F<ï¿½ï¿½8ï¿½ï¿½ï¿½ï¿½ï¿½Aï¿½ ï¿½ï¿½ ï¿½ï¿½# ï¿½`ï¿½4ï¿½0ï¿½ ï¿½	B0ï¿½0vï¿½cï¿½ï¿½C|lï¿½cï¿½ ï¿½Aï¿½Ç„ ># ï¿½`ï¿½ï¿½ï¿½F}L	ï¿½cï¿½ Sï¿½ï¿½, ï¿½A0ï¿½eU}F ï¿½ï¿½ï¿½z,0ï¿½cï¿½!ï¿½ï¿½, ï¿½Adï¿½0Aï¿½mFï¿½1Bï¿½ï¿½C|F ï¿½ï¿½Y	Wï¿½F ï¿½ï¿½aï¿½Wï¿½F ï¿½ï¿½i	Xï¿½F ï¿½ï¿½q	Yï¿½ A0x^bï¿½`ï¿½ï¿½ @ï¿½ï¿½ï¿½00Ãï¿½ï¿½|,ï¿½cï¿½!ï¿½ï¿½ ï¿½ï¿½cï¿½ï¿½ï¿½1Eï¿½ï¿½)ï¿½|,ï¿½cï¿½"ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½X)ï¿½10 ï¿½ï¿½'ï¿½ï¿½F ï¿½ï¿½ï¿½qï¿½S,ï¿½ï¿½bï¿½ï¿½K># ï¿½`ï¿½ï¿½8pï¿½6ï¿½ï¿½|L0ï¿½3b`  ï¿½Yï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½1fï¿½ï¿½5ï¿½|F ï¿½ Zu ï¿½1ï¿½A,0ï¿½cï¿½!ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½cï¿½ ï¿½ï¿½^ gTxï¿½A0PAï¿½
pï¿½	|,ï¿½XPï¿½1ï¿½ï¿½cCï¿½ï¿½E>V(ï¿½1ï¿½ï¿½cï¿½-ï¿½gï¿½ï¿½@ï¿½ï¿½ï¿½sï¿½!Hï¿½tï¿½ï¿½ï¿½ï¿½ï¿½tM Kï¿½ >Èƒ|F ï¿½ 
ï¿½Xï¿½DrF ï¿½ï¿½)ï¿½ï¿½ï¿½#ï¿½@ï¿½ï¿½ï¿½)ï¿½nï¿½ ï¿½&ï¿½ï¿½ï¿½pCï¿½`0ï¿½ ï¿½ï¿½Aï¿½ ï¿½Qtï¿½;ï¿½#	 ï¿½``ï¿½ï¿½]ï¿½E_ï¿½ï¿½Jï¿½$ ï¿½ï¿½wq~ï¿½,1bï¿½  kï¿½IÑˆï¿½ï¿½ <ï¿½qï¿½Q !ï¿½X%ò±€ï¿½
|Lï¿½ï¿½3bï¿½  ï¿½mï¿½ï¿½>Ôƒï¿½ï¿½?ï¿½ï¿½iï¿½ï¿½?ï¿½&ï¿½hï¿½ï¿½&ï¿½h1ï¿½< ï¿½Aï¿½5ï¿½p$Aï¿½ï¿½:Aï¿½	0ï¿½ ï¿½	ï¿½`CJï¿½ï¿½ï¿½ï¿½ï¿½+!\>6ï¿½ï¿½|F ï¿½ï¿½vï¿½,ï¿½ï¿½F ï¿½ï¿½xï¿½,ï¿½!0cï¿½Ïˆï¿½ ï¿½ï¿½oï¿½?$ï¿½ï¿½ï¿½ ï¿½ï¿½oï¿½EHï¿½%#!ï¿½ A0 ï¿½ï¿½X`ï¿½ A0 ï¿½`/	F ï¿½ Zï¿½8ï¿½ï¿½&fï¿½&L'ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½gï¿½Äˆï¿½ï¿½ hï¿½ï¿½Mï¿½Mï¿½`ï¿½Ïˆï¿½ï¿½ |ï¿½ï¿½.1ï¿½	0ï¿½ ï¿½	ï¿½`"ï¿½Ø ï¿½gï¿½ï¿½ @>ï¿½ï¿½ï¿½ï¿½(ï¿½Ñ„ Mï¿½Ñ„Aï¿½ï¿½ï¿½ï¿½
ï¿½|lï¿½ï¿½cï¿½ï¿½Ø ï¿½gï¿½ï¿½ @>ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ñ„ Mï¿½Ñ„Aï¿½ï¿½ï¿½ï¿½
ï¿½|lï¿½ï¿½cï¿½ Sï¿½ï¿½2ï¿½gï¿½ï¿½ @Ä DRC-dc4!ï¿½ï¿½Ygf	ï¿½ï¿½ï¿½!ï¿½fï¿½Rï¿½aï¿½ï¿½ï¿½!ï¿½fï¿½ Rï¿½Aï¿½aï¿½@@ï¿½ï¿½
ï¿½Jï¿½<ï¿½c4! Fï¿½`4aF ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Eï¿½CDF`ï¿½@@ï¿½ï¿½
ï¿½8ï¿½ï¿½=Hd4! Fï¿½`4aF ï¿½ ï¿½ï¿½ï¿½ï¿½=ï¿½EF`ï¿½@@ï¿½ï¿½hï¿½C>Td4! Fï¿½`4aF ï¿½ ï¿½ ï¿½ï¿½=ï¿½ï¿½EF`ï¿½@@ï¿½11Ó˜\ï¿½>`d4! F ï¿½ #ï¿½@ï¿½ï¿½>ï¿½CFF`ï¿½@@ï¿½3QÕ¸ï¿½C?hd4! F ï¿½ï¿½Jï¿½`ï¿½ï¿½Fï¿½ï¿½FF`4AFï¿½ï¿½M>ï¿½mï¿½lï¿½ï¿½pï¿½#`0ï¿½`ï¿½ï¿½ï¿½ï¿½ TqBï¿½ï¿½A">2ï¿½ ï¿½[|,5ï¿½ï¿½Xjlï¿½1X ï¿½Oï¿½cï¿½AL	ï¿½cï¿½@Sï¿½ï¿½ ï¿½ï¿½ï¿½'%BXï¿½ï¿½ï¿½D>6 ï¿½n;ï¿½ï¿½ A0ï¿½BDï¿½ >bï¿½#ï¿½ï¿½jtï¿½ï¿½=ï¿½`ï¿½ï¿½=aï¿½ï¿½=ï¿½aï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½0ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½hï¿½ĞŠï¿½ï¿½ï¿½ï¿½1X ï¿½ï¿½UXdï¿½t0ï¿½q0ï¿½ï¿½3bp  Úªï¿½Hï¿½$ï¿½1!ï¿½ï¿½
ï¿½|F ï¿½ï¿½kï¿½?Mï¿½ï¿½!M[ï¿½!>ï¿½C|l=ï¿½ï¿½ï¿½0ï¿½Ç†A>&ï¿½1ï¿½ï¿½ï¿½	|F ï¿½ï¿½1	,Xï¿½Xpï¿½ï¿½ï¿½0# ï¿½`ï¿½ï¿½Êœ{P(ï¿½ï¿½ï¿½ï¿½@ï¿½?ï¿½cï¿½ï¿½ï¿½?ï¿½cï¿½ï¿½ï¿½ï¿½ï¿½
 ï¿½ >6ï¿½|J!ï¿½1P ï¿½ï¿½]ï¿½DFï¿½p	]Mï¿½ï¿½!Mï¿½ï¿½b1P ï¿½J^ï¿½ï¿½Fï¿½=1ï¿½_Mï¿½ï¿½!Mï¿½ï¿½b1P ï¿½ï¿½^ï¿½Gï¿½PYrMï¿½ï¿½!Mï¿½ï¿½b1P ï¿½ï¿½_ï¿½$L Tï¿½ï¿½tMï¿½ï¿½!Mï¿½ï¿½bï¿½	ï¿½Ïˆï¿½ ï¿½ï¿½ï¿½Êƒ# ï¿½`@ï¿½r*Xp@ï¿½,N># ï¿½`@ ï¿½*ï¿½  ï¿½ï¿½Ìª8\`ï¿½ï¿½ï¿½@># ï¿½`@$ï¿½*# ï¿½`@%ï¿½*4ï¿½1ï¿½ï¿½3bï¿½  dï¿½2ï¿½ï¿½ï¿½A0bï¿½  dï¿½2ï¿½Bï¿½A`kï¿½ï¿½"ï¿½Çï¿½>6ï¿½	|ï¿½Oï¿½ï¿½ï¿½@*ï¿½1ï¿½Tï¿½cÂ«ï¿½Ç„Xï¿½ï¿½ï¿½ï¿½ï¿½F ï¿½ï¿½ï¿½\ï¿½>ï¿½ï¿½T^ï¿½ezï¿½TF`8"Pï¿½oï¿½UR%ï¿½Wï¿½cï¿½ï¿½ï¿½gï¿½ï¿½@ï¿½ï¿½ï¿½R!8Zï¿½fjf\Ze4! ï¿½#Hï¿½ï¿½\ï¿½Uï¿½X@+ï¿½n(ï¿½ï¿½ ï¿½Â‡@g$ï¿½ï¿½Wï¿½cï¿½ï¿½ï¿½ï¿½0^ï¿½ï¿½ï¿½ï¿½ï¿½!>ï¿½+C|F ï¿½@kï¿½v1ï¿½ï¿½ A0ï¿½ï¿½ï¿½]ï¿½aï¿½ï¿½ @ï¿½ï¿½yc18 
nï¿½eï¿½ï¿½ï¿½ A0ï¿½ï¿½&^ï¿½^18 Mnï¿½eï¿½ï¿½ A0ï¿½ï¿½f^aï¿½ï¿½ @4ï¿½ï¿½ï¿½@ï¿½p	ï¿½3bp  ï¿½ï¿½ï¿½K0.# ï¿½`ï¿½ï¿½Í½ï¿½bï¿½Bï¿½Ç„@>Xï¿½%@*ï¿½pï¿½ï¿½!ï¿½ï¿½ï¿½ï¿½ ï¿½>Uyï¿½#
 ï¿½`Pï¿½NÉœK`76ï¿½6ï¿½	0ï¿½ ï¿½	ï¿½0bï¿½  ï¿½ï¿½Ìº/ï¿½3s3ï¿½ ï¿½	B0ï¿½0#
 ï¿½`Pï¿½NË¼KB3>s7ï¿½	0ï¿½ ï¿½	ï¿½0bï¿½  ï¿½ï¿½ï¿½Ì¼4:#6{3ï¿½ ï¿½	B0ï¿½0Fï¿½ ï¿½ A0 ï¿½Ö¹p`ï¿½`ï¿½ @ï¿½ï¿½upï¿½ï¿½!ï¿½ ï¿½cï¿½ ï¿½1@ 2ï¿½ï¿½ï¿½xF ï¿½ï¿½dï¿½g~v:ï¿½ï¿½ ï¿½ A0 ï¿½ï¿½ï¿½ï¿½rï¿½ï¿½`ï¿½ @ï¿½ï¿½vï¿½&ï¿½!ï¿½ï¿½ï¿½cI@3ï¿½ï¿½ï¿½2ï¿½ï¿½cï¿½ï¿½Ç„ï¿½ï¿½ï¿½,A2P1ï¿½ï¿½@ï¿½nHI,ï¿½ï¿½ï¿½ï¿½|f	ï¿½ï¿½ï¿½AIï¿½Aï¿½ ï¿½-ï¿½å‚Y6ï¿½`ï¿½Ï±Æ F ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`gï¿½g|ï¿½fgF`4AFï¿½ï¿½ï¿½ï¿½
a#ï¿½F>6ï¿½
|l0ï¿½ï¿½p6ï¿½1x ï¿½ï¿½ï¿½gtï¿½ï¿½ï¿½ï¿½iï¿½ï¿½Ù›ï¿½M sï¿½F>ï¿½
|ï¿½Rï¿½ï¿½ï¿½ï¿½3bï¿½  dï¿½?ï¿½ï¿½B0bï¿½  dï¿½?ï¿½cG`ï¿½@Ç?ï¿½Ïˆï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½N,ï¿½v [DA># ï¿½`@"ï¿½:ï¿½# ï¿½`@#ï¿½:|ï¿½ï¿½t,ï¿½ï¿½ï¿½ï¿½1ï¿½a>ï¿½cï¿½ ï¿½X ï¿½ï¿½B>&ï¿½10 ï¿½Ç†p'ï¿½$ï¿½ï¿½%},ï¿½3bï¿½  Qï¿½ï¿½ a ï¿½ï¿½Nï¿½ï¿½ A0ï¿½nï¿½vï¿½1X ï¿½ï¿½ï¿½vï¿½qï¿½ï¿½iï¿½.ï¿½ï¿½X]Xñ±º˜ï¿½3bï¿½  ï¿½ï¿½ ï¿½XPï¿½Çï¿½># ï¿½`ï¿½ï¿½ï¿½ï¿½7yï¿½7ï¿½Aï¿½ï¿½tï¿½ï¿½:ï¿½{ Ûƒï¿½pCPC`0Ë°(ï¿½ï¿½ï¿½ï¿½`ï¿½!ï¿½!0ï¿½e`ï¿½ï¿½vï¿½ï¿½cAï¿½ï¿½ï¿½ØGï¿½c6r>ï¿½ ï¿½ï¿½<"xD>6ï¿½ï¿½|ï¿½ï¿½cï¿½0ï¿½Ç>E&l# ï¿½` pD?ï¿½ï¿½?ï¿½	ï¿½0ï¿½0d0ï¿½@4ï¿½,ï¿½3P1ï¿½ï¿½ï¿½4ï¿½8	N3P1ï¿½ï¿½ï¿½4# ï¿½` vï¿½?ï¿½3Bï¿½	ï¿½0ï¿½ ï¿½
B@ï¿½ï¿½@C<Hï¿½3P1Äƒï¿½<C<Hï¿½3PAÄƒï¿½<#
 ï¿½`Pï¿½ï¿½	ï¿½OpG8Gï¿½	0ï¿½ ï¿½	ï¿½0bï¿½  ï¿½)ï¿½ï¿½ï¿½zï¿½Ct4ï¿½ #
 ï¿½`Pï¿½ï¿½ï¿½!C>dG#
 ï¿½`ï¿½ï¿½Rï¿½rC=tGï¿½	0bï¿½  +ï¿½ï¿½ï¿½(6Fy4ï¿½ ï¿½	B0ï¿½0ï¿½0ò±„‘ï¿½)ï¿½|ï¿½Qï¿½Y)
F ï¿½ï¿½ï¿½ï¿½ï¿½Iï¿½ï¿½(ï¿½F`4ï¿½Fï¿½`4ï¿½ï¿½}ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½)ï¿½3bï¿½  ï¿½/ï¿½ï¿½ ï¿½Xï¿½ï¿½ï¿½>ï¿½ï¿½10 ï¿½gï¿½Öˆï¿½ ï¿½ï¿½	ï¿½|l@ï¿½3Üï¿½ï¿½, ï¿½AtNfï¿½]1ï¿½AD|5:ï¿½0CK0ï¿½@Cï¿½0ï¿½PCï¿½0K 
Tv ï¿½@ï¿½`ï¿½
Tv ï¿½@ï¿½ 
ï¿½
Tï¿½ iï¿½@ï¿½ 
ï¿½ï¿½, ï¿½A4Or4ï¿½Ë°LÊ˜ï¿½18 -ï¿½ï¿½(ï¿½!ï¿½ï¿½ï¿½ï¿½Ç†D>6ï¿½|lï¿½ï¿½Ø€ï¿½)<ï¿½'18 1ï¿½'=Ú¡QMï¿½ï¿½! ï¿½Yh
f	ï¿½ï¿½ï¿½ï¿½%gï¿½Xï¿½qï¿½ï¿½ï¿½ï¿½%gï¿½ï¿½mï¿½cCï¿½ï¿½Ç†ï¿½ï¿½ÏˆAï¿½  )Oï¿½ï¿½Oï¿½4ï¿½$ ï¿½ï¿½Rï¿½ï¿½Oï¿½tKÂˆAï¿½  )Oï¿½ï¿½Oï¿½ï¿½$ ï¿½ï¿½Rï¿½ï¿½Oï¿½ï¿½Nmï¿½       